# Conversation 2: Phase 1 Implementation - Step by Step

## Initial Request
User: hey claude, go over this project, understand it, and read the next_steps.md file

Claude: [Explored project structure, read README.md, architecture.md, deploy_plan.md, and logs/next_steps.md]

Project Overview:
- Planning Poker multiplayer browser game
- Current state: Basic MVP with join room, voting (7 cards), manual reveal
- Tech: Node.js + Express + Socket.io + TypeScript (backend), React + Vite + Socket.io-client (frontend)
- Next steps: Transform into 5-stage game (WAITING → STORY_INPUT → THINKING → REVEAL → DISCUSSION)

---

## User Decision
User: lets go with Phase 1. Since Im learning this stack for the first time, i want you to not write code into my project. I just want you to provide the code through here alongside with an explanation of why and what it does.

User: i think do phase 1 but go step by step, feature by feature, not all at once

---

## Step 1: Fix Duplicate Player Interface

### Problem
`server/src/types/index.ts` had Player defined twice (lines 1-4 and 14-19)

### Solution
```typescript
export interface Player {
  id: string
  name: string
  vote?: string                   // optional field since players haven't voted when they first join
  socketId: string                // each player has their own socket connection
}

export interface Room {
  id: string
  players: Map<string, Player>    // key: player ID  -->   value: Player object
  revealed: boolean               // true if votes have been revealed, false otherwise
  currentStory?: string           // what story are players estimating?
}
```

### Why
- TypeScript doesn't allow duplicate interface declarations
- Having it once makes it the "source of truth"
- Better organization: definitions used by others come first

User: ok it seems good

---

## Step 2: Add GameStage Enum

### Question from User
User: is an enum like a state machine?

### Claude's Explanation
No, an enum is NOT a state machine:
- **Enum** = Just a list of possible values (like a menu)
- **State Machine** = The code/logic that enforces rules about transitions

Example:
- Enum defines: RED, YELLOW, GREEN (the colors)
- State machine defines: GREEN → YELLOW → RED → GREEN (the rules)

### Code Added
```typescript
export enum GameStage {
  WAITING = 'WAITING',           // Stage 0: Players vote to start the game
  STORY_INPUT = 'STORY_INPUT',   // Stage 1: Moderator inputs the user story
  THINKING = 'THINKING',         // Stage 2: Players select cards
  REVEAL = 'REVEAL',             // Stage 3: Cards are revealed
  DISCUSSION = 'DISCUSSION'      // Stage 4: Team discusses estimates
}
```

### Why an Enum?
1. Autocomplete in IDE
2. Type safety - catches typos
3. Refactoring safety
4. Self-documenting

User: got it next

---

## Step 3: Add Story Interface

### Code Added
```typescript
export interface Story {
  name: string          // Short title (e.g., "User Login Feature")
  description: string   // Detailed description (e.g., "Users should be able to...")
}
```

### Why?
- Upgrades `currentStory?: string` to structured object
- Groups related data (name + description)
- More extensible for future fields
- Better type safety (both fields exist together or not at all)

User: lets go

---

## Step 4: Update Room to Use Story Type

### Code Changed
```typescript
export interface Room {
  id: string
  players: Map<string, Player>
  revealed: boolean
  currentStory: Story | null      // Changed from currentStory?: string
}
```

### Why `Story | null` instead of `Story?`
- **`?`** means property might not exist (could be `undefined`)
- **`| null`** means property MUST exist but can be `null`
- Better because:
  1. Explicit initialization required
  2. Clearer intent: `null` = "no story yet" vs `undefined` = "forgot to set"
  3. Matches Phase 2 logic where we'll explicitly set `null`

User: lets go

---

## Step 5: Add gameStage Field to Room

### Code Added
```typescript
export interface Room {
  id: string
  players: Map<string, Player>
  revealed: boolean
  currentStory: Story | null
  gameStage: GameStage           // NEW: tracks current game stage
}
```

### Why This Field?
- Heart of the state machine
- Determines: what UI to show, what actions are valid, what happens next
- Type safety via enum prevents mistakes

### Usage Preview (Phase 2)
```typescript
// Creating new room
gameStage: GameStage.WAITING

// Checking stage
if (room.gameStage === GameStage.THINKING) { ... }

// Transitioning
room.gameStage = GameStage.REVEAL
```

User: save this convo to convo2.txt

---

## Current File State

### server/src/types/index.ts
```typescript
export enum GameStage {
  WAITING = 'WAITING',
  STORY_INPUT = 'STORY_INPUT',
  THINKING = 'THINKING',
  REVEAL = 'REVEAL',
  DISCUSSION = 'DISCUSSION'
}

export interface Story {
  name: string
  description: string
}

export interface Player {
  id: string
  name: string
  vote?: string
  socketId: string
}

export interface Room {
  id: string
  players: Map<string, Player>
  revealed: boolean
  currentStory: Story | null
  gameStage: GameStage
}
```

## Next Steps
- Step 6: Add moderatorId field to Room
- Step 7: Add readyPlayers set to Room
- Step 8: Add countdown timer fields to Room
- Step 9: Add ready fields to Player
- Step 10: Mirror types in client/src/types/index.ts
